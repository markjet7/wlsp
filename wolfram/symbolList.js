[
	{
		"name":"scratch",
		"kind":"String",
		"definition":"\"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl\"",
		"children":[
			{
				"name":"z",
				"kind":"Symbol",
				"definition":"z",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl",
					"range":{
						"start":{
							"line":0,
							"character":0
						},
						"end":{
							"line":0,
							"character":1
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[z]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"a",
				"kind":"Symbol",
				"definition":"a",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl",
					"range":{
						"start":{
							"line":2,
							"character":0
						},
						"end":{
							"line":2,
							"character":1
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[a]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"b",
				"kind":"Symbol",
				"definition":"b",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl",
					"range":{
						"start":{
							"line":4,
							"character":0
						},
						"end":{
							"line":4,
							"character":1
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[b]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"iowa",
				"kind":"Symbol",
				"definition":"iowa",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl",
					"range":{
						"start":{
							"line":10,
							"character":0
						},
						"end":{
							"line":10,
							"character":4
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[iowa]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"c",
				"kind":"Symbol",
				"definition":"c",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl",
					"range":{
						"start":{
							"line":12,
							"character":0
						},
						"end":{
							"line":12,
							"character":1
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[c]",
				"icon":"symbol-variable",
				"collapsibleState":1
			}
		],
		"lazyload":"Map[symbolToTreeItem2, Check[getSymbols[\"z = {1, 2, 3, 5}\\n\\na = 9\\n\\nb = <|\\\"a\\\" -> 1, \\\"b\\\" -> 2, \\\"c\\\" -> 3|>\\n\\ncsv = Import[NotebookDirectory[] <> \\\"..\/data\/billion_ton_county\/billionton_county_baseline1.csv\\\", \\\"CSV\\\"];\\n\\ncsv[[{1, 100}]] \/\/TableForm\\n\\niowa = SelectFirst[csv, #[[5]] === \\\"Iowa\\\" &]\\n\\nc = \\\"54544f\\\"\\n\\n\\ncsv[[All,5]]\/\/DeleteDuplicates\\n\\n\", \"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl\"], {}]]",
		"icon":"file-code",
		"location":{
			"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/scratch.wl"
		},
		"collapsibleState":1
	},
	{
		"name":"functions",
		"kind":"String",
		"definition":"\"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl\"",
		"children":[
			{
				"name":"GetResources",
				"kind":"Symbol",
				"definition":"GetResources",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":65,
							"character":0
						},
						"end":{
							"line":65,
							"character":12
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[GetResources]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"FilterCountiesRandomly",
				"kind":"Symbol",
				"definition":"FilterCountiesRandomly",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":106,
							"character":0
						},
						"end":{
							"line":106,
							"character":22
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[FilterCountiesRandomly]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"biorefineryFeedstocks",
				"kind":"Symbol",
				"definition":"biorefineryFeedstocks",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":143,
							"character":0
						},
						"end":{
							"line":143,
							"character":21
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[biorefineryFeedstocks]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"getAvailableFeedstock",
				"kind":"Symbol",
				"definition":"getAvailableFeedstock",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":145,
							"character":0
						},
						"end":{
							"line":145,
							"character":21
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[getAvailableFeedstock]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"filterByWeights",
				"kind":"Symbol",
				"definition":"filterByWeights",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":306,
							"character":0
						},
						"end":{
							"line":306,
							"character":15
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[filterByWeights]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"filterBySmallestCost",
				"kind":"Symbol",
				"definition":"filterBySmallestCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":310,
							"character":0
						},
						"end":{
							"line":310,
							"character":20
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[filterBySmallestCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"capitalCost",
				"kind":"Symbol",
				"definition":"capitalCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":321,
							"character":0
						},
						"end":{
							"line":321,
							"character":11
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[capitalCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"collectionCost",
				"kind":"Symbol",
				"definition":"collectionCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":322,
							"character":0
						},
						"end":{
							"line":322,
							"character":14
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[collectionCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"deliveryCost",
				"kind":"Symbol",
				"definition":"deliveryCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":323,
							"character":0
						},
						"end":{
							"line":323,
							"character":12
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[deliveryCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"operatingCost",
				"kind":"Symbol",
				"definition":"operatingCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":324,
							"character":0
						},
						"end":{
							"line":324,
							"character":13
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[operatingCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"co2CaptureCost",
				"kind":"Symbol",
				"definition":"co2CaptureCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":325,
							"character":0
						},
						"end":{
							"line":325,
							"character":14
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[co2CaptureCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"co2CompressionCost",
				"kind":"Symbol",
				"definition":"co2CompressionCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":326,
							"character":0
						},
						"end":{
							"line":326,
							"character":18
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[co2CompressionCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"h2liquefactionCost",
				"kind":"Symbol",
				"definition":"h2liquefactionCost",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":327,
							"character":0
						},
						"end":{
							"line":327,
							"character":18
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[h2liquefactionCost]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"costsBySite",
				"kind":"Symbol",
				"definition":"costsBySite",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":348,
							"character":0
						},
						"end":{
							"line":348,
							"character":11
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[costsBySite]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"plotBiorefineryCostByCapacity",
				"kind":"Symbol",
				"definition":"plotBiorefineryCostByCapacity",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":366,
							"character":0
						},
						"end":{
							"line":366,
							"character":29
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[plotBiorefineryCostByCapacity]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"GroupBiorefineriesBy",
				"kind":"Symbol",
				"definition":"GroupBiorefineriesBy",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":480,
							"character":0
						},
						"end":{
							"line":480,
							"character":20
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[GroupBiorefineriesBy]",
				"icon":"symbol-variable",
				"collapsibleState":1
			},
			{
				"name":"GroupBiorefineriesByTwo",
				"kind":"Symbol",
				"definition":"GroupBiorefineriesByTwo",
				"location":{
					"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl",
					"range":{
						"start":{
							"line":487,
							"character":0
						},
						"end":{
							"line":487,
							"character":23
						}
					}
				},
				"children":[],
				"lazyload":"symbolToTreeItem2[GroupBiorefineriesByTwo]",
				"icon":"symbol-variable",
				"collapsibleState":1
			}
		],
		"lazyload":"Map[symbolToTreeItem2, Check[getSymbols[\"(* ::Package:: *)\\n\\n(* files = FileNames[\\\"*.csv\\\", \\n   \\\".\/\\\" <> \\\"data\/billion_ton\\\"];\\ndb = <|StringTake[FileBaseName[#], {17, -1}] -> Import[#, \\\"CSV\\\"] & \/@ \\n    files[[1 ;;]]|>; *)\\nsameCountyQ[c_, s_]:=(c[\\\"County\\\"] == (s[\\\"CountyG\\\"]) && c[\\\"State\\\"] == s[\\\"StateG\\\"]);\\n\\nLoadCountyCSV[]:=Import[FileNameJoin[{\\\".\/\\\", \\\"..\\\", \\\"data\\\",\\\"billionton_county_download20211119-044647.csv\\\", \\\"billionton_county_download20211119-044647.csv\\\"}], \\\"CSV\\\"] \/\/ \\n    Map[Function[{row}, AssociationThread[First@# -> row] ], Rest@#] &;\\n\\n\\nLoadCountyCSV[filter_]:=LoadCountyCSV[] \/\/ filter;\\n\\nLoadCountyGraphics[]:= Function[{shpfile},MapThread[\\n        <|\\\"CountyG\\\" -> #1, \\\"StateG\\\" -> #2, \\\"Lat\\\" -> #3, \\\"Lon\\\" -> #4, \\\"Graphics\\\" -> #5|> &,\\n        {\\n            First@(\\\"COUNTY\\\" \/. (\\\"LabeledData\\\" \/. shpfile)),\\n            First@(\\\"STATE\\\" \/. (\\\"LabeledData\\\" \/. shpfile)),\\n            First@(\\\"LATITUDE\\\" \/. (\\\"LabeledData\\\" \/. shpfile)),\\n            First@(\\\"LONGITUDE\\\" \/. (\\\"LabeledData\\\" \/. shpfile)),\\n            First@(\\\"Geometry\\\" \/. shpfile)\\n        }\\n    ]][Import[FileNameJoin[{\\\".\/\\\", \\\"..\\\", \\\"data\\\",\\\"agmap\\\", \\\"agmap.shp\\\"}], {\\\"SHP\\\", \\\"Data\\\"}]];\\n\\nLoadCountyGraphics[filter_]:= LoadCountyGraphics[] \/\/ filter;\\n\\nLoadCountyDataGraphics[]:= MergeCountyDataGraphics[\\n    LoadCountyCSV[],\\n    LoadCountyGraphics[]\\n];\\n\\nLoadCountyDataGraphics[countyFilter_, graphicsFilter_]:= MergeCountyDataGraphics[\\n    LoadCountyCSV[countyFilter],\\n    LoadCountyGraphics[graphicsFilter]\\n];\\n\\nLoadCachedData[] :=Import[FileNameJoin[{\\\".\/\\\", \\\"data\\\",\\\"county_data.mx\\\"}]];\\n\\nSaveCountyDataGraphics[]:= Export[FileNameJoin[{\\\".\/\\\", \\\"data\\\",\\\"county_data.mx\\\"}], Select[LoadCountyDataGraphics[], KeyExistsQ[#, \\\"Resource\\\"] &], \\\"WXF\\\"];\\n\\nSaveFullCountyDataGraphics[]:=Module[{data, data2, files, db},\\n    data = Select[LoadCountyDataGraphics[], KeyExistsQ[#, \\\"Resource\\\"] &];\\n    files = FileNames[\\\"*.csv\\\", \\\".\/\\\" <> \\\"data\/billion_ton\\\"];\\n    db = <|StringTake[FileBaseName[#], {17,-1}] -> Import[#, \\\"CSV\\\"] &\/@ files|>;\\n    data2 = Table[\\n        Table[\\n            row[feed \/\/ StringReplace[{\\\"_\\\" -> \\\" \\\"}] \/\/ StringReplace[{x_~~y___:>ToUpperCase@x <> y}]] = SelectFirst[db[feed], #[[3]] == row[\\\"County\\\"] && #[[2]] == row[\\\"StateFull\\\"] &, {0, 0, 0, 0}][[4]],\\n            {feed, Keys@db}\\n        ];\\n        row,\\n        {row, data}\\n    ];\\n    Export[FileNameJoin[{\\\".\/\\\", \\\"data\\\",\\\"full_county_data.mx\\\"}], data2, \\\"WXF\\\"];\\n];\\n\\nMergeCountyDataGraphics[counties_, shapes_]:=Map[\\n    Function[{shape},\\n        Check[Join[shape, SelectFirst[counties, sameCountyQ[#, shape] &]], shape]\\n    ],\\n    shapes\\n];\\n\\n\\n\\nGetResources[counties_]:=DeleteDuplicates[counties[[All, \\\"Resource\\\"]]]\\n\\nbilt[f_, p_, y_, pu_, du_, co2h_, co2t_, co2p_, co2c_, co2g_, ctf_, ctv_, cc_, cl_, co_, c_, od_, pc_]:= <|\\n        \\\"feedstock\\\" -> f,\\n        \\\"product\\\" -> p, \\n        \\\"conversion\\\" -> y,\\n        \\\"product units\\\" -> pu,\\n        \\\"demand units\\\" -> du,\\n        \\\"co2 harvesting\\\" -> co2h,\\n        \\\"co2 transportation\\\" -> co2t,\\n        \\\"co2 production\\\" -> co2p,\\n        \\\"co2 captured\\\" -> co2c,\\n        \\\"co2 gen used\\\" -> co2g,\\n        \\\"cost transportation fixed\\\" -> ctf,\\n        \\\"cost transportation variable\\\" -> ctv,\\n        \\\"cost capital\\\" -> cc,\\n        \\\"cost lifetime\\\" -> cl,\\n        \\\"cost operating\\\" -> co,\\n        \\\"capacity\\\" -> c,\\n        \\\"operating days\\\" -> od,\\n        \\\"production cost\\\" -> pc\\n    |>;\\n\\nloadBILT[path_:FileNameJoin[{\\\".\/\\\", \\\"..\\\", \\\"data\\\",\\\"Example BILT biomass allocation calculation_220316.xlsx\\\"}]] := Module[{d}, \\n    d = Import[path, \\\"XLSX\\\"][[1]];\\n    Map[Apply[bilt, #] &, d[[4;;, 7;;24]]]\\n];\\n\\ntoTonnes = <|\\n    \\\"bu\\\" -> 56\/2205,\\n    \\\"lb\\\" -> 1\/2205,\\n    \\\"dt\\\" -> 1,\\n    \\\"null\\\" -> 0\\n|>;\\n\\n\\n\\n(* ::Section:: *)\\n(*Filter Functions*)\\n\\n\\nFilterCountiesRandomly[counties_, number_]:= RandomSample[counties, number]\\n\\nFilterSmallestCountiesBySize[counties_, max_]:=Select[counties, #[\\\"Production\\\"]*units[#[\\\"Production Unit\\\"]] <= max &];\\n\\nFilterLargestCountiesBySize[counties_, min_]:=Select[counties, #[\\\"Production\\\"]*units[#[\\\"Production Unit\\\"]] >= min &];\\n\\nFilterCountiesByProductionFraction[counties_, fraction_]:=Fold[\\n    Function[{all, next}, If[\\n         Total[all[[All, \\\"Production\\\"]]*(units \/@ all[[All, \\\"Production Unit\\\"]])] \/\\n    Total[counties[[All, \\\"Production\\\"]]*(units \/@ counties[[All, \\\"Production Unit\\\"]])] <= fraction,\\n    Append[all, next],\\n    all\\n    ]], \\n    {First@counties},\\n    Rest@counties\\n];\\n\\nFilterCountiesByResource[counties_, resource_String]:=Select[counties, #[\\\"Resource\\\"] === resource &];\\n\\n\\n\\n(* ::Section:: *)\\n(*Analyze Resources*)\\n\\n\\nfeedstockGroups = <|\\n    \\\"Forestry\\\" -> {\\\"Hardwood, lowland logging residues\\\", \\\"Hardwood, upland logging residues\\\", \\\"Other forest residue\\\", \\\"Other forest thinnings\\\", \\\"Hardwood, lowland whole trees\\\", \\\"Hardwood, upland whole trees\\\", \\\"Mixedwood logging residues\\\", \\\"Mixedwood whole trees\\\", \\\"Primary mill residue\\\", \\\"Secondary mill residue\\\", \\\"Softwood, natural logging residues\\\", \\\"Softwood, natural whole trees\\\", \\\"Softwood, planted logging residues\\\", \\\"Softwood, planted whole trees\\\"},\\n    \\\"Straws\\\" -> {\\\"Barley straw\\\", \\\"Wheat straw\\\", \\\"Barley\\\",\\\"Hay\\\",\\\"Oats straw\\\",  \\\"Wheat\\\", \\\"Biomass sorghum\\\"},\\n    \\\"Switchgrass\\\" -> {\\\"Switchgrass\\\", \\\"Miscanthus\\\"},\\n    \\\"Wood\\\" -> {\\\"Poplar\\\", \\\"Pine\\\", \\\"Willow\\\", \\\"Eucalyptus\\\"},\\n    \\\"Agriculture\\\" -> {\\\"Corn stover\\\", \\\"Rice straw\\\", \\\"Cotton residue\\\", \\\"Sugarcane bagasse\\\", \\\"Noncitrus residues\\\", \\\"Tree nut residues\\\", \\\"Citrus residues\\\", \\\"Rice hulls\\\", \\\"Sugarcane trash\\\", \\\"Hog manure\\\", \\\"Milk cow manure\\\"},\\n    \\\"Other Sugars\\\" -> {\\\"Energy cane\\\", \\\"Sorghum\\\"},\\n    \\\"Corn Grain\\\" -> {\\\"Corn\\\"},\\n    \\\"MSW\\\" -> {\\\"Wheat straw\\\", \\\"Construction & demolition waste\\\", \\\"Paper and paperboard\\\", \\\"Other municipal solid waste\\\", \\\"Food waste\\\", \\\"Cotton gin trash\\\", \\\"Municipal solid waste wood\\\", \\\"Yard trimmings\\\"},\\n    \\\"Oils\\\" -> {\\\"Soybeans\\\"},\\n    \\\"Other\\\" -> { \\\"Cotton\\\",  \\\"Idle Land\\\", \\\"Oats\\\", \\\"Pastureland available\\\", \\\"Plastics\\\", \\\"Rice\\\", \\\"Rubber and leather\\\", \\\"Sorghum stubble\\\", \\\"Textiles\\\"}\\n|>;\\nbiorefineryFeedstocks[b_]:=Select[feedstockGroups, MemberQ[#, b[\\\"feedstock\\\"]] &]\\n\\ngetAvailableFeedstock[counties_, feedstocks_ : {\\\"Barley straw\\\", \\\"Biomass sorghum\\\",\\n     \\\"Corn stover\\\", \\\"Energy cane\\\", \\\"Eucalyptus\\\",\\n     \\\"Miscanthus\\\", \\\"Pine\\\", \\\"Poplar\\\", \\\"Softwood natural residue\\\", \\\"Softwood planted residue\\\",\\n     \\\"Switchgrass\\\", \\\"Wheat straw\\\", \\\"Willow\\\"}] :=\\n    Module[{},\\n        GroupBy[Flatten[Table[{f, c[\\\"CountyG\\\"], c[f]}, {c, counties},\\n             {f, feedstocks}], 1], First, Total[#[[All, 3]]]&] \/\/\\n        Sort \/\/\\n        Reverse\\n    ]\\n\\n\\n(* ::Section:: *)\\n(*Biorefinery Assignment Section*)\\n\\n\\nAssignBiorefineriesRandomly[counties_, biorefineries_]:=Module[{biorefinery}, Table[\\n    biorefinery = RandomChoice[Select[biorefineries, #BiorefineryFeedstock === county[\\\"Resource\\\"] &]];\\n    Join[county, biorefinery],\\n    {county, counties}\\n]];\\n\\nAssignBiorefineriesByWeight[counties_, biorefineries_]:=Module[{allbiorefineries, biorefinery},\\n    Table[\\n        allbiorefineries = Select[biorefineries, #BiorefineryFeedstock === county[\\\"Resource\\\"] &];\\n        biorefinery = RandomChoice[allbiorefineries[[All, \\\"BiorefineryWeight\\\"]] -> allbiorefineries];\\n        Join[county, biorefinery],\\n        {county, counties}\\n]];\\n\\nAssignBiorefineriesByCost[counties_, biorefineries_]:=Table[\\n    allbiorefineries = Select[biorefineries, #BiorefineryFeedstock === county[\\\"Resource\\\"] &];\\n    byCosts = Map[{#, BiorefineryCountyCost[county, #]} &, allbiorefineries];\\n    Join[county, SortBy[byCosts, Last][[1, 1]]],\\n\\n    {county, counties}\\n];\\n\\nplotCounties[counties_, factor_]:=Module[{shps, rescaled, out},\\n    shps = LoadCountyGraphics[];\\n    rescaled = MapThread[Join[#1, <|\\\"output\\\" -> #2|>] &, {counties, Rescale[counties[[All, factor]]]}];\\n    out = Map[\\n        Function[{s}, Join[s, <|\\\"output\\\" -> SelectFirst[rescaled, sameCountyQ[#1, s] &, <|\\\"output\\\" -> 0|>][\\\"output\\\"]|>]], \\n        shps];\\n    Graphics[\\n        Flatten@Map[\\n            {ColorData[\\\"GreenBrownTerrain\\\"][#output], #[\\\"Graphics\\\"]} &,\\n            out\\n        ]\\n    ]\\n];\\n\\nmyGeoDistance[from_, to_]:=myGeoDistance[from, to]=QuantityMagnitude[GeoDistance[from, to]];\\n\\ngetCostsByCapacity[deployments_, biorefinery_, counties_List, max_:2*^6]:=Module[{sortedCountiesByDistance, gatheredBiomass},\\n    sortedCountiesByDistance = SortBy[counties, myGeoDistance[Values@#[[{\\\"Lat\\\", \\\"Lon\\\"}]], Values@deployments[[{\\\"Lat\\\", \\\"Lon\\\"}]]] &];\\n    gatheredBiomass = gatherBiomass[{}, deployments, biorefinery, sortedCountiesByDistance, max];\\n    Table[\\n        totalBiomass = Total[gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        totalProduct = Total[gatheredBiomass[[1;;g, \\\"Biomass\\\"]]]*gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"product units\\\"];\\n        collectionCosts = Total[gatheredBiomass[[1;;g, \\\"Collection Cost\\\"]]*gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        deliveryCosts = Total[gatheredBiomass[[1;;g, \\\"Delivery Cost\\\"]]*gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        capitalCosts = 0.13*biorefineryCost[totalBiomass, gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"capacity\\\"]*gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"cost capital\\\"]];\\n        operatingCosts = gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"cost operating\\\"];\\n        {\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], collectionCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], deliveryCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], operating\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], capitalCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], (collectionCosts + deliveryCosts + capitalCosts + operatingCosts)\/totalProduct}    \\n        },\\n        {g, Length@gatheredBiomass}\\n    ]\/\/ Transpose \/\/ AssociationThread[{\\n            \\\"Collection\\\",\\n            \\\"Delivery\\\",\\n            \\\"Operating\\\",\\n            \\\"Capital\\\",\\n            \\\"Total\\\"}->#]&\\n];\\n\\ngetLowestCostByCapacity[deployments_, biorefinery_, counties_List, max_:2*^6]:=Module[{sortedCountiesByDistance, gatheredBiomass},\\n    sortedCountiesByDistance = SortBy[counties, GeoDistance[Values@#[[{\\\"Lat\\\", \\\"Lon\\\"}]], Values@deployments[[{\\\"Lat\\\", \\\"Lon\\\"}]]] &];\\n    gatheredBiomass = gatherBiomass[{}, deployments, biorefinery, sortedCountiesByDistance, max];\\n    pastCost = 1*^9;\\n    optimalCapacity = 0;\\n    Table[\\n        totalBiomass = Total[gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        totalProduct = Total[gatheredBiomass[[1;;g, \\\"Biomass\\\"]]]*gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"product units\\\"];\\n        collectionCosts = Total[gatheredBiomass[[1;;g, \\\"Collection Cost\\\"]]*gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        deliveryCosts = Total[gatheredBiomass[[1;;g, \\\"Delivery Cost\\\"]]*gatheredBiomass[[1;;g, \\\"Biomass\\\"]]];\\n        capitalCosts = 0.13*biorefineryCost[totalBiomass, gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"capacity\\\"]*gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"cost capital\\\"]];\\n        operatingCosts = gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"cost operating\\\"];\\n        totalCost = (collectionCosts + deliveryCosts + capitalCosts + operatingCosts)\/totalProduct;\\n        If[totalCost > pastCost*1.10, optimalCost = pastCost; Return[];, pastCost = totalCost];\\n        {\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], collectionCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], deliveryCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], operating\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], capitalCosts\/totalProduct},\\n            {totalBiomass\/ gatheredBiomass[[g]][\\\"Biorefinery\\\"][\\\"operating days\\\"], totalCost}    \\n        },\\n        {g, Length@gatheredBiomass}\\n    ]\/\/ Transpose \/\/ AssociationThread[{\\n            \\\"Collection\\\",\\n            \\\"Delivery\\\",\\n            \\\"Operating\\\",\\n            \\\"Capital\\\",\\n            \\\"Total\\\"}->#]&\\n];\\n\\n\\n\\ntotalProduction[counties_]:=Total[counties[[All, \\\"Production\\\"]]*toTonnes\/@counties[[All, \\\"Production Unit\\\"]]];\\n\\ngetClusters[counties_, n_:30]:=Module[{},\\n    FindClusters[\\n        Values[counties[[All, {\\\"Lat\\\", \\\"Lon\\\", \\\"Production\\\"}]]] -> counties,\\n        n,\\n        \\\"Method\\\" -> \\\"KMeans\\\"\\n        ] \/\/ Map[Association, #,{2}] & \/\/\\n        SortBy[#, N@Mean[#[[All, \\\"Production\\\"]]] &] & \/\/ Reverse\\n];\\n\\n\\nbtToBilt = <|\\n    \\\"Corn\\\" -> {\\\"Corn stover\\\", \\\"AtJ-SPK\\\"}, \\n    \\\"Idle Land\\\" -> {\\\"\\\",\\\"\\\"}, \\n    \\\"Barley\\\" -> {\\\"Barley straw\\\", \\\"AtJ-SPK\\\"},\\n    \\\"Soybeans\\\" -> {\\\"\\\",\\\"\\\"}, \\n    \\\"Hay\\\" -> {\\\"Wheat straw\\\", \\\"FT-SPK\\\"}, \\n    \\\"Rice\\\" -> {\\\"Wheat straw\\\", \\\"FT-SPK\\\"},\\n    \\\"Pastureland available\\\" -> {\\\"\\\",\\\"\\\"},\\n    \\\"Cotton\\\" -> {\\\"\\\",\\\"\\\"}, \\n    \\\"Wheat\\\" -> {\\\"Wheat straw\\\", \\\"FT-SPK\\\"}\\n|>;\\n\\n\\n\\n\\n\\n(* feedstockByWeight = SemanticImport[\\\".\/\\\" <> \\\"data\/feedstockWeights.csv\\\", {String, Real, Real, Real, Real, Real}, \\\"NamedRows\\\", Delimiters -> \\\",\\\"]; *)\\nfilterByFeedstockWeight[counties_, biorefineries_, s_, placed_]:=Module[{},\\n    largestResources = Select[feedstockByWeight[[All, \\\"Feedstock\\\"]], Total[counties[[All, #]]] > 50000 &];\\n\\n    choices = Flatten@Table[\\n        weights = Map[\\n            Function[{bio},\\n            SelectFirst[\\n                feedstockByWeight, \\n                #[\\\"Feedstock\\\"] == resource && KeyExistsQ[#, bio[\\\"product\\\"]]  &, <|bio[\\\"product\\\"] -> 0|>][bio[\\\"product\\\"]]], biorefineries];\\n\\n        RandomChoice[weights->biorefineries, 1],\\n        {resource, largestResources}\\n    ];\\n\\n    choices\\n];\\n\\n\\n\\n\\nfilterByWeights[counties_, biorefineries_, s_, placed_]:=Module[{},\\n    Break[]\\n]\\n\\nfilterBySmallestCost[counties_, biorefineries_, s_, placed_]:=TakeSmallestBy[\\n            Select[\\n                Association@Map[#->If[\\n                    KeyExistsQ[counties[[1]], #[\\\"feedstock\\\"]],\\n                    biorefineryCost[s, counties[[1;;2]], #],\\n                    {0, 1*^9}] &, biorefineries],\\n                    #[[1]] > 100 &]\\n                    , #[[2]] &, 1] \/\/ Keys \\n\\n\\n\\ncapitalCost[m_, m0_, c0_, n_:0.7, i_:0.13]:=i*c0*(m\/m0)^n\\ncollectionCost[m_, cf0_:3.103, cv0_, y0_:3200, f0_:0.6, t_:1.5]:=m*cf0 + m*cv0*t*Sqrt[m\/(Pi*y0*f0)]\\ndeliveryCost[m_, d_, d0_:25, c0_:0.71, m0_:2000*330, t_:1.5]:=t*m*c0*(d+5)\\noperatingCost[m_, m0_,o0_]:=o0*(m\/m0)\\nco2CaptureCost[co2_, co20_:5391.09, c0_:233.92, n_:0.61, op0_:0.064, i_:0.13]:=(1*^6*i*c0*(co2\/co20)^n + op0*co2)\\nco2CompressionCost[co2_, co20_:4848.94, c0_:30.38, n_:0.77, op0_:0.073, i_:0.13]:=(1*^6*i*c0*(co2\/co20)^n + op0*co2)\\nh2liquefactionCost[h2_, c0_:7.23, n_:0.8, op0_:8.763]:=(1*^6*c0*(h2)^n + op0*h2)\\n\\n\\n\\nbiorefineryCost[site_List, counties_, biorefinery_, capacity_?NumberQ]:=Module[{sortedCounties, costs, sites,m,  o, cap, c, d,p, co2cap, co2comp}, \\n    sortedCounties = SortBy[counties, (#[\\\"Lat\\\"]-site[[1]])^2+(#[\\\"Lon\\\"]-site[[2]])^2 &][[1;;UpTo@300]];\\n\\tcosts = costsBySite[site, sortedCounties, biorefinery, capacity, 0, {}];\\n\\tsites = costs[[All,1]];\\n\\tm = costs[[All,2]];\\n\\tp = Total[m]*biorefinery[\\\"conversion\\\"]+1.0;\\n\\to = operatingCost[capacity, 2000*330, biorefinery[\\\"cost operating\\\"]];\\n\\tcap = capitalCost[capacity, 2000*330, biorefinery[\\\"cost capital\\\"], 0.7,0.13 ];\\n    co2cap = co2CaptureCost[(biorefinery[\\\"co2 captured\\\"] + biorefinery[\\\"co2 production\\\"])*p\/(330)];\\n    co2comp = co2CompressionCost[(biorefinery[\\\"co2 captured\\\"] + biorefinery[\\\"co2 production\\\"])*p\/330];\\n    (* h2liquefaction = h2liquefactionCost[biorefinery[\\\"h2 liquefaction\\\"]*p]; *)\\n\\tc = Total@costs[[All,3]];\\n\\td = Total@costs[[All,4]];\\n\\n    {sites, m, (c+d+o+cap+co2cap+co2comp)\/p, c\/p, d\/p, o\/p,cap\/p,co2cap\/p,co2comp\/p}\\n];\\n\\ncostsBySite[site_List, counties_, biorefinery_Association,capacity_, gathered_, costs_]:=Module[{nearestCounty, availableFeedstock, newFeedstock, c, d, p},\\n\\tIf[(gathered >= capacity) || (counties == {}),\\n\\t\\tcosts,\\n\\t\\t\\n\\t\\tnearestCounty = First@counties;\\n\\t\\tavailableFeedstock = Total[Values@nearestCounty[[Flatten@Values@biorefineryFeedstocks[biorefinery]]]]+1.0;\\n\\t\\tnewFeedstock = If[gathered +availableFeedstock > capacity,  capacity-gathered, availableFeedstock];\\n\\t\\tc = collectionCost[newFeedstock, biorefinery[\\\"cost transportation fixed\\\"], biorefinery[\\\"cost transportation variable\\\"]];\\n\\t\\td = deliveryCost[newFeedstock, QuantityMagnitude@GeoDistance[site, Values[nearestCounty[[{\\\"Lat\\\", \\\"Lon\\\"}]]]]];\\n\\t\\tp = biorefinery[\\\"conversion\\\"]*(gathered + newFeedstock);\\n\\t\\tCheck[costsBySite[site, Rest@counties, biorefinery, capacity, gathered+newFeedstock, \\n\\t\\t\\tAppend[costs,\\n\\t\\t\\t{nearestCounty, newFeedstock,c,d}]],\\n            costs]\\n\\t]\\t\\n]\\n\\n\\nplotBiorefineryCostByCapacity[site_, counties_,biorefinery_, min_, max_]:=Module[{},\\n\\tListPlot[\\n\\t\\tTranspose@Table[\\n\\t\\t\\tTake[biorefineryCost[site, counties, biorefinery, x],{4,9}],\\n\\t\\t{x, min, max, 100000}],\\n\\t\\tPlotLabels -> {\\\"Collection\\\",\\\"Delivery\\\",\\\"Operating\\\",\\\"Capital\\\", \\\"CO2 Capture\\\", \\\"CO2 Compression\\\"},\\n\\t\\tPlotRange->All\\n\\t]\\n]\\n\\n\\n\\n\\n\\noptimalBiorefineryCapacityCost[site_List, counties0_, biorefinery_] :=\\n    Module[{f, result, sol},\\n        f[x0_?NumericQ] :=\\n            (\\n                result = biorefineryCost[site, counties0, biorefinery, x0];\\n                result[[3]]\\n            );\\n        sol = Quiet@FindMinimum[f[x1], {x1, 720000, 10000, 720000*10}];\\n        <|\\\"site\\\" -> site, \\n        \\\"counties\\\" -> result[[1]], \\n        \\\"Capacity\\\" -> Total[result[[2]]] \/ 330.0, \\n        \\\"Biofuel Cost\\\" -> result[[3]], \\n        \\\"Biofuel Out\\\" -> Total[result[[2]]]*biorefinery[\\\"conversion\\\"], \\\"Feedstock\\\" -> biorefinery[\\\"feedstock\\\"], \\n        \\\"Product\\\" -> biorefinery[\\\"product\\\"], \\\"Biorefinery\\\" -> biorefinery, \\\"CO2\\\" -> Total[result[[2]]]*biorefinery[\\\"co2 captured\\\"]|>\\n    ];\\n\\njetFuelFirst[counties_, biorefineries_, site_, placed_] :=\\n    Module[{},\\n        aviationBiorefineries = Select[placed, #[[\\\"Biorefinery\\\", \\\"product\\\"\\n            ]] == \\\"AtJ-SPK\\\"&];\\n        If[Total[330 * aviationBiorefineries[[All, \\\"Capacity\\\"]] * aviationBiorefineries\\n            [[All, \\\"Biorefinery\\\", \\\"conversion\\\"]]] < 650*^6,\\n            Select[biorefineries, (#[\\\"product\\\"] == \\\"AtJ-SPK\\\")&]\\n            ,\\n            Select[biorefineries, !(#[\\\"product\\\"] == \\\"AtJ-SPK\\\")&]\\n        ]\\n    ];\\n\\nfilterJetFuelFirstThenByWeight[counties_, biorefineries_, site_, placed_\\n    ] :=\\n    Module[{},\\n        aviationBiorefineries = Select[placed, #[[\\\"Biorefinery\\\", \\\"product\\\"\\n            ]] == \\\"AtJ-SPK\\\"&];\\n        If[Total[aviationBiorefineries[[All, \\\"Biofuel Out\\\"]]] < 650*^6,\\n            \\n            Select[biorefineries, (#[\\\"product\\\"] == \\\"AtJ-SPK\\\")&]\\n            ,\\n            filterByFeedstockWeight[counties, Select[biorefineries, !\\n                (#[\\\"product\\\"] == \\\"AtJ-SPK\\\")&], site, placed]\\n        ]\\n    ];\\n\\nPlaceRefineries::usage = \\\"PlaceRefineries[counties, sites, filter, biorefineries] places biorefineries in sites, based on the counties and the filter. The filter is a function that takes the counties and biorefineries and returns, for example, the \\\\\\\"smallest cost\\\\\\\", \\\\\\\"random weight\\\\\\\", or \\\\\\\"smallest cost and random weight\\\\\\\". The result is an association of sites and the gathered results (counties, total capacity, cost, and biorefinery).\\\";\\n\\nPlaceRefineries[data_, sites_, filter_, biorefineries_, minCapacity_:\\n    30000] :=\\n    Module[{obc, nb0},\\n        gs = {};\\n        results07 =\\n            Flatten[\\n                Table[\\n                    rs = Complement[data, Flatten[gs[[All, \\\"counties\\\"\\n                        ]]]];\\n                    ns = SortBy[rs, (#[\\\"Lat\\\"] - s[[1]]) ^ 2 + (#[\\\"Lon\\\"\\n                        ] - s[[2]]) ^ 2&];\\n                    nb0 = Take[ns, UpTo[25]];\\n                    If[Length @ nb0 > 0,\\n                        sb = filter[nb0, biorefineries, s, gs];\\n                        Map[\\n                            (\\n                                obc = optimalBiorefineryCapacityCost[\\n                                    s, nb0, #];\\n                                AppendTo[gs, obc];\\n                                obc\\n                            )&\\n                            ,\\n                            sb\\n                        ]\\n                        ,\\n                        {<|\\\"Capacity\\\" -> 0|>}\\n                    ]\\n                    ,\\n                    {s, sites}\\n                ]\\n                ,\\n                1\\n            ];\\n        Select[results07, #[[\\\"Capacity\\\"]] * 330 > minCapacity&]\\n    ];\\n\\ngatherBiomass[counties_, biorefinery_, n_:1, r0_:Infinity] :=\\n    Module[{m, p, r, gathered, site, sources, co2c},\\n        site = SpatialMedian[Values @ counties[[1 ;; n, {\\\"Lat\\\", \\\"Lon\\\"\\n            }]]];\\n        feedstocks = Values@biorefineryFeedstocks[biorefinery];\\n        sources = counties[[1 ;; n]];\\n        {m, r} = biorefineryCost[site, sources, biorefinery];\\n        co2c = m * biorefinery[\\\"co2 captured\\\"];\\n        p = m * biorefinery[\\\"conversion\\\"];\\n        gathered = <|\\\"site\\\" -> site, \\\"counties\\\" -> sources, \\\"Capacity\\\"\\n             -> m \/ 330.0, \\\"Biofuel Cost\\\" -> r, \\\"Product\\\" -> p, \\\"Biorefinery\\\" -> \\n            biorefinery, \\\"CO2\\\" -> co2c|>;\\n        If[And[r < 1.1 * r0, m < 4.5*^6, n < 20],\\n            gatherBiomass[counties, biorefinery, n + 1, r]\\n            ,\\n            gathered\\n        ]\\n    ];\\n\\n\\nGroupBiorefineriesBy[results_, category_, value_]:=GroupBy[results, \\n    #[\\\"Biorefinery\\\"][category] &,\\n    Map[\\n        GeoPosition[#[[\\\"site\\\"]]] -> #[value] &\\n    ]\\n]\\n\\nGroupBiorefineriesByTwo[results_, category1_, category2_, value_]:=GroupBy[results, \\n    {#[\\\"Biorefinery\\\"][category1], #[\\\"Biorefinery\\\"][category2]} &,\\n    Map[\\n        GeoPosition[#[[\\\"site\\\"]]] -> #[value] &\\n    ]\\n]\\n\\nSummarizeBiorefineriesBy[results_, category_, value_, function_]:= Map[\\n        function[#[[All, 2]]] &,\\n        GroupBiorefineriesBy[results, category, value]\\n    ];\\n\\nChartBiorefineriesBy[groups_]:=GeoBubbleChart[\\n    groups,\\n    GeoRange -> Entity[\\\"Country\\\", \\\"UnitedStates\\\"],\\n    ChartStyle -> 2,\\n    BubbleSizes->{0.03, 0.1},\\n    ChartLegends -> {Placed[\\n        SwatchLegend[\\n            MapIndexed[ColorData[2][#2[[1]]] &, Keys@groups],\\n            Keys[groups],\\n            LegendLayout -> {\\\"Column\\\", 1},\\n            Background -> White,\\n            LegendFunction -> Frame,\\n            LegendLabel -> \\\"Group\\\",\\n            LabelStyle -> 20\\n        ], {0.9, 0.2}],\\n        Placed[\\n        PointLegend[\\n            {Gray, Gray, Gray},\\n            (NumberForm[#, {3,0}] &\/@{\\n                Min[Flatten@Values@groups[[All, All, 2]]],\\n                Median[Flatten@Values@groups[[All, All, 2]]],\\n                Max[Flatten@Values@groups[[All, All, 2]]]\\n            }),\\n            LegendLayout -> {\\\"Column\\\", 1},\\n            LegendMarkerSize -> {30, 50, 100},\\n            Background -> White,\\n            LegendFunction -> Frame,\\n            LegendLabel -> \\\"Capacity (MTPD)\\\",\\n            LabelStyle -> 20\\n        ], {0.1, 0.2}]},\\n    ImageSize -> 20*72\\n];\\n\\n\\npostResults[results_, label_]:= Module[{},\\n    byFeedstockCapacity  = GroupBiorefineriesBy[results, \\\"feedstock\\\", \\\"Capacity\\\"];\\n    byFeedstockCost = GroupBiorefineriesBy[results, \\\"feedstock\\\", \\\"Biofuel Cost\\\"];\\n    byProductCapacity = GroupBiorefineriesBy[results, \\\"product\\\", \\\"Capacity\\\"];\\n\\n    totalsByFeedstockCapacity = SummarizeBiorefineriesBy[results, \\\"feedstock\\\", \\\"Capacity\\\",  Total];\\n    meansByProductCost = SummarizeBiorefineriesBy[results, \\\"product\\\", \\\"Biofuel Cost\\\", Mean];\\n\\n    byFeedstockProductCapacity = GroupBiorefineriesByTwo[results, \\\"feedstock\\\", \\\"product\\\", \\\"Capacity\\\"];\\n\\n    KeyValueMap[\\n        Function[{k, v} , Flatten@{k, Min[v[[All, 2]]], Mean[v[[All, 2]]], Max[v[[All, 2]]]}], byFeedstockProductCapacity] \/\/ SortBy[Last] \/\/ Reverse \/\/ Grid;\\n\\n    DistributionChart[\\n        byProductCapacity[[All,All,2]],\\n        BarOrigin -> Left,\\n        ChartLabels -> KeyValueMap[Function[{k,v} , k <> \\\" (\\\" <> \\n        ToString[NumberForm[Mean[v[[All, 2]]], {2,1}]] <> \\n        \\\"\\\\[PlusMinus] \\\" <>  \\n        ToString[\\n        NumberForm[\\n        If[Length[v[[All,2]]]>2,StandardDeviation[v[[All, 2]]],0], {2,1}]] <> \\\")\\\"], byProductCapacity],\\n        ChartElementFunction -> \\\"Quantile\\\",\\n        Frame -> True,\\n        FrameLabel -> {\\\"Biorefinery Capacity (MTPD)\\\", None},\\n        ImageSize -> 15*72\\n    ]  \/\/ Export[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label , \\\"_biorefinery_capacity_by_product_histogram.png\\\"}], #] &;\\n\\n    DistributionChart[\\n        byProductCapacity[[All, All, 2]],\\n        BarOrigin -> Left,\\n        ChartLabels -> KeyValueMap[Function[{k,v} , k <> \\\" (\\\" <> ToString[NumberForm[Mean[v[[All, 2]]], {2,1}]] <> \\\"\\\\[PlusMinus] \\\" <>  ToString[NumberForm[\\n        If[Length[v[[All,2]]]>2,StandardDeviation[v[[All, 2]]],0], {2,1}]] <> \\\")\\\"], byProductCapacity],\\n        ChartElementFunction -> \\\"Quantile\\\",\\n        Frame -> True,\\n        FrameLabel -> {\\\"Biorefinery Capacity (MTPD)\\\", None},\\n        ImageSize -> 15*72\\n    ]  \/\/ Export[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label , \\\"_biorefinery_capacity_by_product_histogram.png\\\"}], #]  &;\\n\\n    plot1 = ChartBiorefineriesBy[byFeedstockCapacity];\\n    plot1 \/\/ Export[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label ,  \\\"_map_by_feedstock.png\\\"}], #] &;\\n    plot2 = ChartBiorefineriesBy[byProductCapacity];\\n    plot2  \/\/ EExport[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label ,  \\\"_map_by_fuel.png\\\"}], #] &;\\n\\n    grouped = GroupBy[results,\\n        #[\\\"Biorefinery\\\"][\\\"feedstock\\\"] &\\n    ];\\n\\n    g= KeyValueMap[\\n        Function[{k, v} ,\\n        ListPlot[\\n            v[[All, {\\\"Capacity\\\", \\\"Biofuel Cost\\\"}]],\\n            PlotLabel -> k,\\n            ImageSize -> 10*72\\n        ]],\\n        grouped\\n    ];\\n\\n\\n    grouped = GroupBy[\\n            results,\\n            #[\\\"Biorefinery\\\"][\\\"product\\\"] &,\\n            #[[All, \\\"Capacity\\\"]] &\\n        ];\\n\\n    Histogram[\\n        grouped,\\n        ChartLegends -> SwatchLegend[\\n            Keys@grouped\\n        ],\\n        Frame -> True,\\n        FrameLabel -> {\\\"Capacity (MTPD)\\\", \\\"Biorefineries\\\"},\\n        ChartStyle -> 1,\\n        PlotRange -> {All, All},\\n        ImageSize -> 10*72\\n    ] \/\/ Export[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label ,  \\\"_capacity_histogram.png\\\"}], #] &;\\n\\n    byFeedstockProductCapacityCounts=Flatten[KeyValueMap[\\n        {StringRiffle[#1,\\\"-\\\"],\\n        HistogramList[\\n        #2[[All,2]],{{0,1000,2000,3000,4000,5000,10000,15000}}][[2]]}&,\\n        KeySort[byFeedstockProductCapacity]],{1}];\\n\\n    byFeedstockProductCapacityCountsSorted = SortBy[byFeedstockProductCapacityCounts, Total[#[[2]]]&];\\n    BarChart[\\n        byFeedstockProductCapacityCountsSorted[[All,2]],\\n        ChartLayout -> \\\"Stacked\\\",\\n        ChartLabels->{byFeedstockProductCapacityCountsSorted[[All,1]],None},\\n        BarOrigin->Left,\\n        Frame->True,\\n        FrameLabel->{None,\\\"Biorefinery Counts\\\"},\\n        ChartLegends->SwatchLegend[sizes[[1]],LegendLabel->\\\"Biorefinery\\\\nCapacities\\\\n(MTPD)\\\"],\\n        ImageSize->15*72\\n    ]\/\/ Export[FileNameJoin[{\\\".\/\\\" , \\\"..\\\",  \\\"figures\\\" , label ,  \\\"_capacity_counts.png\\\"}], #] &;\\n\\n    capByCost = GroupBy[\\n        results,\\n        #[\\\"Biorefinery\\\"][\\\"product\\\"] &,\\n        #[[All, {\\\"Capacity\\\", \\\"Biofuel Cost\\\"}]] &\\n    ];\\n\\n    linearFits = Map[\\n        NonlinearModelFit[Select[Values@#1, #[[2]] < 30 &], a*x^(n-1), {a,n},x] &,\\n        capByCost\\n    ];\\n\\n    p1 = ListPlot[\\n        Values\/@capByCost,\\n        PlotLegends -> Automatic,\\n        Frame -> True,\\n        FrameLabel -> {\\\"Biorefinery Capacity (MTPD)\\\", \\\"Biofuel Cost ($\/gallon)\\\"},\\n        LabelStyle -> 30,\\n        ImageSize -> 10*72\\n    ] ;\\n\\n    p2 = Plot[\\n            Evaluate@Table[l[x], {l, linearFits}],\\n            {x, 10, 1600},\\n            PlotStyle -> Dashed\\n        ];\\n\\n    Show@@{p1, p2}\\n\\n    \\n];\\n\\n\\n\\n\\n\\n\", \"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl\"], {}]]",
		"icon":"file-code",
		"location":{
			"uri":"file:\/\/\/Users\/mark\/Projects\/National%20Getting%20to%20Negative\/code\/functions.wl"
		},
		"collapsibleState":1
	}
]